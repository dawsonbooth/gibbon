{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gibbon \u00b6 Description \u00b6 Organize the files in your filesystem according to their attributes. Installation \u00b6 With Python installed, simply run the following command to add the package to your project. 1 python -m pip install gibbon Usage \u00b6 The following is an example usage of the package: 1 2 3 4 from gibbon import Tree with Tree ( \"/path/to/root/folder/\" , glob = \"**/*.txt\" ) as tree : tree . flatten () Feel free to check out the docs for more information. License \u00b6 This software is released under the terms of MIT license .","title":"Overview"},{"location":"#gibbon","text":"","title":"gibbon"},{"location":"#description","text":"Organize the files in your filesystem according to their attributes.","title":"Description"},{"location":"#installation","text":"With Python installed, simply run the following command to add the package to your project. 1 python -m pip install gibbon","title":"Installation"},{"location":"#usage","text":"The following is an example usage of the package: 1 2 3 4 from gibbon import Tree with Tree ( \"/path/to/root/folder/\" , glob = \"**/*.txt\" ) as tree : tree . flatten () Feel free to check out the docs for more information.","title":"Usage"},{"location":"#license","text":"This software is released under the terms of MIT license .","title":"License"},{"location":"reference/gibbon/","text":"Module gibbon \u00b6 None None View Source from .tree import Tree __all__ = [ \"Tree\" ] Sub-modules \u00b6 gibbon.tree gibbon.types gibbon.util Classes \u00b6 Tree \u00b6 1 2 3 4 5 6 7 class Tree ( root_src : 'Union[str, os.PathLike[str]]' , glob : 'str' , root_dest : 'Optional[Union[str, os.PathLike[str]]]' = None , parse : 'Optional[Callable[[Path], T]]' = None , show_progress : 'bool' = False ) View Source class Tree ( Generic [ T ] ) : root_src : Path root_dest : Path glob : str parse : Optional [ Callable[[Path ] , T ]] show_progress : bool sources : Tuple [ Path, ... ] = tuple () operations : Dict [ str, Callable[[Path, T ] , Path ]] = dict () def __init__ ( self , root_src : Union [ str, os.PathLike[str ] ] , glob : str , root_dest : Optional [ Union[str, os.PathLike[str ] ]] = None , parse : Optional [ Callable[[Path ] , T ]] = None , show_progress : bool = False , ) : self . root_src = Path ( root_src ) self . root_dest = Path ( root_dest or root_src ) self . glob = glob self . parse = parse self . show_progress = show_progress self . refresh () def refresh ( self ) -> Tree [ T ] : self . sources = tuple ( self . root_src . glob ( self . glob )) return self def organize ( self , * ordering : Callable [ [T ] , Stringable ] ) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename : Callable [ [T ] , str ] ) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self def resolve ( self ) -> Tree [ T ] : if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values () : destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ) : shutil . rmtree ( source . parent ) self . refresh () return self def __enter__ ( self ) -> Tree [ T ] : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve () Ancestors (in MRO) \u00b6 typing.Generic Class variables \u00b6 1 operations 1 sources Methods \u00b6 flatten \u00b6 1 2 3 def flatten ( self ) -> 'Tree' View Source def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self organize \u00b6 1 2 3 4 def organize ( self , * ordering : 'Callable[[T], Stringable]' ) -> 'Tree' View Source def organize ( self , * ordering : Callable [ [T ] , Stringable ] ) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self refresh \u00b6 1 2 3 def refresh ( self ) -> 'Tree[T]' View Source def refresh ( self ) -> Tree [ T ] : self . sources = tuple ( self . root_src . glob ( self . glob )) return self rename \u00b6 1 2 3 4 def rename ( self , create_filename : 'Callable[[T], str]' ) -> 'Tree' View Source def rename ( self , create_filename : Callable [ [T ] , str ] ) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self resolve \u00b6 1 2 3 def resolve ( self ) -> 'Tree[T]' View Source def resolve ( self ) -> Tree [ T ] : if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values () : destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ) : shutil . rmtree ( source . parent ) self . refresh () return self","title":"Index"},{"location":"reference/gibbon/#module-gibbon","text":"None None View Source from .tree import Tree __all__ = [ \"Tree\" ]","title":"Module gibbon"},{"location":"reference/gibbon/#sub-modules","text":"gibbon.tree gibbon.types gibbon.util","title":"Sub-modules"},{"location":"reference/gibbon/#classes","text":"","title":"Classes"},{"location":"reference/gibbon/#tree","text":"1 2 3 4 5 6 7 class Tree ( root_src : 'Union[str, os.PathLike[str]]' , glob : 'str' , root_dest : 'Optional[Union[str, os.PathLike[str]]]' = None , parse : 'Optional[Callable[[Path], T]]' = None , show_progress : 'bool' = False ) View Source class Tree ( Generic [ T ] ) : root_src : Path root_dest : Path glob : str parse : Optional [ Callable[[Path ] , T ]] show_progress : bool sources : Tuple [ Path, ... ] = tuple () operations : Dict [ str, Callable[[Path, T ] , Path ]] = dict () def __init__ ( self , root_src : Union [ str, os.PathLike[str ] ] , glob : str , root_dest : Optional [ Union[str, os.PathLike[str ] ]] = None , parse : Optional [ Callable[[Path ] , T ]] = None , show_progress : bool = False , ) : self . root_src = Path ( root_src ) self . root_dest = Path ( root_dest or root_src ) self . glob = glob self . parse = parse self . show_progress = show_progress self . refresh () def refresh ( self ) -> Tree [ T ] : self . sources = tuple ( self . root_src . glob ( self . glob )) return self def organize ( self , * ordering : Callable [ [T ] , Stringable ] ) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename : Callable [ [T ] , str ] ) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self def resolve ( self ) -> Tree [ T ] : if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values () : destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ) : shutil . rmtree ( source . parent ) self . refresh () return self def __enter__ ( self ) -> Tree [ T ] : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve ()","title":"Tree"},{"location":"reference/gibbon/#ancestors-in-mro","text":"typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/gibbon/#class-variables","text":"1 operations 1 sources","title":"Class variables"},{"location":"reference/gibbon/#methods","text":"","title":"Methods"},{"location":"reference/gibbon/#flatten","text":"1 2 3 def flatten ( self ) -> 'Tree' View Source def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self","title":"flatten"},{"location":"reference/gibbon/#organize","text":"1 2 3 4 def organize ( self , * ordering : 'Callable[[T], Stringable]' ) -> 'Tree' View Source def organize ( self , * ordering : Callable [ [T ] , Stringable ] ) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self","title":"organize"},{"location":"reference/gibbon/#refresh","text":"1 2 3 def refresh ( self ) -> 'Tree[T]' View Source def refresh ( self ) -> Tree [ T ] : self . sources = tuple ( self . root_src . glob ( self . glob )) return self","title":"refresh"},{"location":"reference/gibbon/#rename","text":"1 2 3 4 def rename ( self , create_filename : 'Callable[[T], str]' ) -> 'Tree' View Source def rename ( self , create_filename : Callable [ [T ] , str ] ) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self","title":"rename"},{"location":"reference/gibbon/#resolve","text":"1 2 3 def resolve ( self ) -> 'Tree[T]' View Source def resolve ( self ) -> Tree [ T ] : if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values () : destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ) : shutil . rmtree ( source . parent ) self . refresh () return self","title":"resolve"},{"location":"reference/gibbon/tree/","text":"Module gibbon.tree \u00b6 None None View Source from __future__ import annotations import os import shutil from concurrent.futures import ProcessPoolExecutor from pathlib import Path from typing import Callable , Dict , Generic , Iterable , Optional , Tuple , Union from tqdm import tqdm from .types import Stringable , T from .util import is_empty , safe_move def build_parent ( item : T , * ordering : Callable [[ T ], Stringable ]) -> Path : parent = Path () for getter in ordering : parent /= str ( getter ( item )) return parent class Tree ( Generic [ T ]): root_src : Path root_dest : Path glob : str parse : Optional [ Callable [[ Path ], T ]] show_progress : bool sources : Tuple [ Path , ... ] = tuple () operations : Dict [ str , Callable [[ Path , T ], Path ]] = dict () def __init__ ( self , root_src : Union [ str , os . PathLike [ str ]], glob : str , root_dest : Optional [ Union [ str , os . PathLike [ str ]]] = None , parse : Optional [ Callable [[ Path ], T ]] = None , show_progress : bool = False , ): self . root_src = Path ( root_src ) self . root_dest = Path ( root_dest or root_src ) self . glob = glob self . parse = parse self . show_progress = show_progress self . refresh () def refresh ( self ) -> Tree [ T ]: self . sources = tuple ( self . root_src . glob ( self . glob )) return self def organize ( self , * ordering : Callable [[ T ], Stringable ]) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename : Callable [[ T ], str ]) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self def resolve ( self ) -> Tree [ T ]: if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values (): destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ): shutil . rmtree ( source . parent ) self . refresh () return self def __enter__ ( self ) -> Tree [ T ]: return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve () Functions \u00b6 build_parent \u00b6 1 2 3 4 def build_parent ( item : 'T' , * ordering : 'Callable[[T], Stringable]' ) -> 'Path' View Source def build_parent ( item : T , * ordering : Callable [ [T ] , Stringable ] ) -> Path : parent = Path () for getter in ordering : parent /= str ( getter ( item )) return parent Classes \u00b6 Tree \u00b6 1 2 3 4 5 6 7 class Tree ( root_src : 'Union[str, os.PathLike[str]]' , glob : 'str' , root_dest : 'Optional[Union[str, os.PathLike[str]]]' = None , parse : 'Optional[Callable[[Path], T]]' = None , show_progress : 'bool' = False ) View Source class Tree ( Generic [ T ] ) : root_src : Path root_dest : Path glob : str parse : Optional [ Callable[[Path ] , T ]] show_progress : bool sources : Tuple [ Path, ... ] = tuple () operations : Dict [ str, Callable[[Path, T ] , Path ]] = dict () def __init__ ( self , root_src : Union [ str, os.PathLike[str ] ] , glob : str , root_dest : Optional [ Union[str, os.PathLike[str ] ]] = None , parse : Optional [ Callable[[Path ] , T ]] = None , show_progress : bool = False , ) : self . root_src = Path ( root_src ) self . root_dest = Path ( root_dest or root_src ) self . glob = glob self . parse = parse self . show_progress = show_progress self . refresh () def refresh ( self ) -> Tree [ T ] : self . sources = tuple ( self . root_src . glob ( self . glob )) return self def organize ( self , * ordering : Callable [ [T ] , Stringable ] ) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename : Callable [ [T ] , str ] ) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self def resolve ( self ) -> Tree [ T ] : if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values () : destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ) : shutil . rmtree ( source . parent ) self . refresh () return self def __enter__ ( self ) -> Tree [ T ] : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve () Ancestors (in MRO) \u00b6 typing.Generic Class variables \u00b6 1 operations 1 sources Methods \u00b6 flatten \u00b6 1 2 3 def flatten ( self ) -> 'Tree' View Source def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self organize \u00b6 1 2 3 4 def organize ( self , * ordering : 'Callable[[T], Stringable]' ) -> 'Tree' View Source def organize ( self , * ordering : Callable [ [T ] , Stringable ] ) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self refresh \u00b6 1 2 3 def refresh ( self ) -> 'Tree[T]' View Source def refresh ( self ) -> Tree [ T ] : self . sources = tuple ( self . root_src . glob ( self . glob )) return self rename \u00b6 1 2 3 4 def rename ( self , create_filename : 'Callable[[T], str]' ) -> 'Tree' View Source def rename ( self , create_filename : Callable [ [T ] , str ] ) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self resolve \u00b6 1 2 3 def resolve ( self ) -> 'Tree[T]' View Source def resolve ( self ) -> Tree [ T ] : if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values () : destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ) : shutil . rmtree ( source . parent ) self . refresh () return self","title":"Tree"},{"location":"reference/gibbon/tree/#module-gibbontree","text":"None None View Source from __future__ import annotations import os import shutil from concurrent.futures import ProcessPoolExecutor from pathlib import Path from typing import Callable , Dict , Generic , Iterable , Optional , Tuple , Union from tqdm import tqdm from .types import Stringable , T from .util import is_empty , safe_move def build_parent ( item : T , * ordering : Callable [[ T ], Stringable ]) -> Path : parent = Path () for getter in ordering : parent /= str ( getter ( item )) return parent class Tree ( Generic [ T ]): root_src : Path root_dest : Path glob : str parse : Optional [ Callable [[ Path ], T ]] show_progress : bool sources : Tuple [ Path , ... ] = tuple () operations : Dict [ str , Callable [[ Path , T ], Path ]] = dict () def __init__ ( self , root_src : Union [ str , os . PathLike [ str ]], glob : str , root_dest : Optional [ Union [ str , os . PathLike [ str ]]] = None , parse : Optional [ Callable [[ Path ], T ]] = None , show_progress : bool = False , ): self . root_src = Path ( root_src ) self . root_dest = Path ( root_dest or root_src ) self . glob = glob self . parse = parse self . show_progress = show_progress self . refresh () def refresh ( self ) -> Tree [ T ]: self . sources = tuple ( self . root_src . glob ( self . glob )) return self def organize ( self , * ordering : Callable [[ T ], Stringable ]) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename : Callable [[ T ], str ]) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self def resolve ( self ) -> Tree [ T ]: if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values (): destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ): shutil . rmtree ( source . parent ) self . refresh () return self def __enter__ ( self ) -> Tree [ T ]: return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve ()","title":"Module gibbon.tree"},{"location":"reference/gibbon/tree/#functions","text":"","title":"Functions"},{"location":"reference/gibbon/tree/#build_parent","text":"1 2 3 4 def build_parent ( item : 'T' , * ordering : 'Callable[[T], Stringable]' ) -> 'Path' View Source def build_parent ( item : T , * ordering : Callable [ [T ] , Stringable ] ) -> Path : parent = Path () for getter in ordering : parent /= str ( getter ( item )) return parent","title":"build_parent"},{"location":"reference/gibbon/tree/#classes","text":"","title":"Classes"},{"location":"reference/gibbon/tree/#tree","text":"1 2 3 4 5 6 7 class Tree ( root_src : 'Union[str, os.PathLike[str]]' , glob : 'str' , root_dest : 'Optional[Union[str, os.PathLike[str]]]' = None , parse : 'Optional[Callable[[Path], T]]' = None , show_progress : 'bool' = False ) View Source class Tree ( Generic [ T ] ) : root_src : Path root_dest : Path glob : str parse : Optional [ Callable[[Path ] , T ]] show_progress : bool sources : Tuple [ Path, ... ] = tuple () operations : Dict [ str, Callable[[Path, T ] , Path ]] = dict () def __init__ ( self , root_src : Union [ str, os.PathLike[str ] ] , glob : str , root_dest : Optional [ Union[str, os.PathLike[str ] ]] = None , parse : Optional [ Callable[[Path ] , T ]] = None , show_progress : bool = False , ) : self . root_src = Path ( root_src ) self . root_dest = Path ( root_dest or root_src ) self . glob = glob self . parse = parse self . show_progress = show_progress self . refresh () def refresh ( self ) -> Tree [ T ] : self . sources = tuple ( self . root_src . glob ( self . glob )) return self def organize ( self , * ordering : Callable [ [T ] , Stringable ] ) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self def rename ( self , create_filename : Callable [ [T ] , str ] ) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self def resolve ( self ) -> Tree [ T ] : if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values () : destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ) : shutil . rmtree ( source . parent ) self . refresh () return self def __enter__ ( self ) -> Tree [ T ] : return self def __exit__ ( self , * args ) -> None : if None in args : self . resolve ()","title":"Tree"},{"location":"reference/gibbon/tree/#ancestors-in-mro","text":"typing.Generic","title":"Ancestors (in MRO)"},{"location":"reference/gibbon/tree/#class-variables","text":"1 operations 1 sources","title":"Class variables"},{"location":"reference/gibbon/tree/#methods","text":"","title":"Methods"},{"location":"reference/gibbon/tree/#flatten","text":"1 2 3 def flatten ( self ) -> 'Tree' View Source def flatten ( self ) -> Tree : self . operations [ \"flatten\" ] = lambda path , _ : self . root_dest / path . name self . operations . pop ( \"organize\" , None ) return self","title":"flatten"},{"location":"reference/gibbon/tree/#organize","text":"1 2 3 4 def organize ( self , * ordering : 'Callable[[T], Stringable]' ) -> 'Tree' View Source def organize ( self , * ordering : Callable [ [T ] , Stringable ] ) -> Tree : self . operations [ \"organize\" ] = lambda path , item : self . root_dest / build_parent ( item , * ordering ) / path . name self . operations . pop ( \"flatten\" , None ) return self","title":"organize"},{"location":"reference/gibbon/tree/#refresh","text":"1 2 3 def refresh ( self ) -> 'Tree[T]' View Source def refresh ( self ) -> Tree [ T ] : self . sources = tuple ( self . root_src . glob ( self . glob )) return self","title":"refresh"},{"location":"reference/gibbon/tree/#rename","text":"1 2 3 4 def rename ( self , create_filename : 'Callable[[T], str]' ) -> 'Tree' View Source def rename ( self , create_filename : Callable [ [T ] , str ] ) -> Tree : self . operations [ \"rename\" ] = lambda path , item : path . parent / create_filename ( item ) return self","title":"rename"},{"location":"reference/gibbon/tree/#resolve","text":"1 2 3 def resolve ( self ) -> 'Tree[T]' View Source def resolve ( self ) -> Tree [ T ] : if len ( self . operations ) == 0 : return self # Parse files parsed_sources : Iterable [ Tuple ] if self . parse is not None : with ProcessPoolExecutor () as executor : parsed_sources = zip ( self . sources , executor . map ( self . parse , self . sources )) else : parsed_sources = zip ( self . sources , self . sources ) # Perform operations if self . show_progress : parsed_sources = tqdm ( parsed_sources , desc = \"Process files\" , total = len ( self . sources )) destinations = list () for source , parsed in parsed_sources : destination = source try : for operate in self . operations . values () : destination = operate ( destination , parsed ) except Exception as e : destination = self . root_dest / e . __class__ . __name__ / destination . name destinations . append ( destination ) self . operations . clear () # Move files paths = zip ( self . sources , destinations ) if self . show_progress : paths = tqdm ( paths , desc = \"Move files\" , total = len ( self . sources )) for source , destination in paths : safe_move ( source , destination ) if is_empty ( source . parent , ignore_dirs = True ) : shutil . rmtree ( source . parent ) self . refresh () return self","title":"resolve"},{"location":"reference/gibbon/types/","text":"Module gibbon.types \u00b6 None None View Source from typing import TypeVar T = TypeVar ( \"T\" ) class Stringable : ... def __str__ ( self ) -> str : ... Variables \u00b6 1 T Classes \u00b6 Stringable \u00b6 1 2 3 4 5 class Stringable ( / , * args , ** kwargs ) View Source class Stringable: ... def __str__ ( self ) -> str: ...","title":"Types"},{"location":"reference/gibbon/types/#module-gibbontypes","text":"None None View Source from typing import TypeVar T = TypeVar ( \"T\" ) class Stringable : ... def __str__ ( self ) -> str : ...","title":"Module gibbon.types"},{"location":"reference/gibbon/types/#variables","text":"1 T","title":"Variables"},{"location":"reference/gibbon/types/#classes","text":"","title":"Classes"},{"location":"reference/gibbon/types/#stringable","text":"1 2 3 4 5 class Stringable ( / , * args , ** kwargs ) View Source class Stringable: ... def __str__ ( self ) -> str: ...","title":"Stringable"},{"location":"reference/gibbon/util/","text":"Module gibbon.util \u00b6 None None View Source import os import shutil from pathlib import Path def safe_move ( source : Path , destination : Path ) -> None : if source == destination : return if not destination . parent . exists (): os . makedirs ( destination . parent ) shutil . move ( str ( source ), str ( destination )) return if not destination . exists (): shutil . move ( str ( source ), str ( destination )) return stem , suffix = destination . stem , destination . suffix destination = destination . parent / f \" { stem } (1) { suffix } \" i = 1 while destination . exists (): destination = destination . parent / f \" { stem } ( { i } ) { suffix } \" i += 1 shutil . move ( str ( source ), str ( destination )) def is_empty ( folder : Path , ignore_dirs : bool = False ): for f in folder . rglob ( \"*\" ): if not ignore_dirs or ( ignore_dirs and not f . is_dir ()): return False return True Functions \u00b6 is_empty \u00b6 1 2 3 4 def is_empty ( folder : pathlib . Path , ignore_dirs : bool = False ) View Source def is_empty ( folder : Path , ignore_dirs : bool = False ) : for f in folder . rglob ( \" * \" ) : if not ignore_dirs or ( ignore_dirs and not f . is_dir ()) : return False return True safe_move \u00b6 1 2 3 4 def safe_move ( source : pathlib . Path , destination : pathlib . Path ) -> None View Source def safe_move ( source : Path , destination : Path ) -> None : if source == destination : return if not destination . parent . exists () : os . makedirs ( destination . parent ) shutil . move ( str ( source ), str ( destination )) return if not destination . exists () : shutil . move ( str ( source ), str ( destination )) return stem , suffix = destination . stem , destination . suffix destination = destination . parent / f \"{stem} (1){suffix}\" i = 1 while destination . exists () : destination = destination . parent / f \"{stem} ({i}){suffix}\" i += 1 shutil . move ( str ( source ), str ( destination ))","title":"Util"},{"location":"reference/gibbon/util/#module-gibbonutil","text":"None None View Source import os import shutil from pathlib import Path def safe_move ( source : Path , destination : Path ) -> None : if source == destination : return if not destination . parent . exists (): os . makedirs ( destination . parent ) shutil . move ( str ( source ), str ( destination )) return if not destination . exists (): shutil . move ( str ( source ), str ( destination )) return stem , suffix = destination . stem , destination . suffix destination = destination . parent / f \" { stem } (1) { suffix } \" i = 1 while destination . exists (): destination = destination . parent / f \" { stem } ( { i } ) { suffix } \" i += 1 shutil . move ( str ( source ), str ( destination )) def is_empty ( folder : Path , ignore_dirs : bool = False ): for f in folder . rglob ( \"*\" ): if not ignore_dirs or ( ignore_dirs and not f . is_dir ()): return False return True","title":"Module gibbon.util"},{"location":"reference/gibbon/util/#functions","text":"","title":"Functions"},{"location":"reference/gibbon/util/#is_empty","text":"1 2 3 4 def is_empty ( folder : pathlib . Path , ignore_dirs : bool = False ) View Source def is_empty ( folder : Path , ignore_dirs : bool = False ) : for f in folder . rglob ( \" * \" ) : if not ignore_dirs or ( ignore_dirs and not f . is_dir ()) : return False return True","title":"is_empty"},{"location":"reference/gibbon/util/#safe_move","text":"1 2 3 4 def safe_move ( source : pathlib . Path , destination : pathlib . Path ) -> None View Source def safe_move ( source : Path , destination : Path ) -> None : if source == destination : return if not destination . parent . exists () : os . makedirs ( destination . parent ) shutil . move ( str ( source ), str ( destination )) return if not destination . exists () : shutil . move ( str ( source ), str ( destination )) return stem , suffix = destination . stem , destination . suffix destination = destination . parent / f \"{stem} (1){suffix}\" i = 1 while destination . exists () : destination = destination . parent / f \"{stem} ({i}){suffix}\" i += 1 shutil . move ( str ( source ), str ( destination ))","title":"safe_move"}]}